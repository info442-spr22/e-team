{"ast":null,"code":"import { lerp } from './math-utils';\nimport { scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nvar EPSILON = 0.01;\nvar VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nexport default function flyToViewport(startProps, endProps, t) {\n  var viewport = {};\n  var rho = 1.414;\n  var startZoom = startProps.zoom;\n  var startCenter = [startProps.longitude, startProps.latitude];\n  var startScale = zoomToScale(startZoom);\n  var endZoom = endProps.zoom;\n  var endCenter = [endProps.longitude, endProps.latitude];\n  var scale = zoomToScale(endZoom - startZoom);\n  var startCenterXY = lngLatToWorld(startCenter, startScale);\n  var endCenterXY = lngLatToWorld(endCenter, startScale);\n  var uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  var w0 = Math.max(startProps.width, startProps.height);\n  var w1 = w0 / scale;\n  var u1 = vec2.length(uDelta);\n\n  if (Math.abs(u1) < EPSILON) {\n    for (var _i = 0; _i < VIEWPORT_TRANSITION_PROPS.length; _i++) {\n      var key = VIEWPORT_TRANSITION_PROPS[_i];\n      var startValue = startProps[key];\n      var endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n\n    return viewport;\n  }\n\n  var rho2 = rho * rho;\n  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);\n  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);\n  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  var S = (r1 - r0) / rho;\n  var s = t * S;\n  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  var scaleIncrement = 1 / w;\n  var newZoom = startZoom + scaleToZoom(scaleIncrement);\n  var newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  vec2.scale(newCenterWorld, newCenterWorld, scaleIncrement);\n  var newCenter = worldToLngLat(newCenterWorld, zoomToScale(newZoom));\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}","map":{"version":3,"mappings":"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","names":["lerp","scaleToZoom","zoomToScale","lngLatToWorld","worldToLngLat","vec2","EPSILON","VIEWPORT_TRANSITION_PROPS","flyToViewport","startProps","endProps","t","viewport","rho","startZoom","zoom","startCenter","longitude","latitude","startScale","endZoom","endCenter","scale","startCenterXY","endCenterXY","uDelta","sub","w0","Math","max","width","height","w1","u1","length","abs","key","startValue","endValue","rho2","b0","b1","r0","log","sqrt","r1","S","s","w","cosh","u","tanh","sinh","scaleIncrement","newZoom","newCenterWorld","add","newCenter"],"sources":["/Users/yuemincao/Documents/INFO442/e-team/e-safety/node_modules/viewport-mercator-project/src/fly-to-viewport.js"],"sourcesContent":["import {lerp} from './math-utils';\nimport {\n  scaleToZoom,\n  zoomToScale,\n  lngLatToWorld,\n  worldToLngLat\n} from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n*/\n/* eslint-disable max-statements */\nexport default function flyToViewport(startProps, endProps, t) {\n  // Equations from above paper are referred where needed.\n\n  const viewport = {};\n\n  // TODO: add this as an option for applications.\n  const rho = 1.414;\n\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter, startScale);\n  const endCenterXY = lngLatToWorld(endCenter, startScale);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta);\n  // u0 is treated as '0' in Eq (9).\n\n  // If change in center is too small, do linear interpolaiton.\n  if (Math.abs(u1) < EPSILON) {\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  const s = t * S;\n\n  const w = (Math.cosh(r0) / Math.cosh(r0 + rho * s));\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  vec2.scale(newCenterWorld, newCenterWorld, scaleIncrement);\n\n  const newCenter = worldToLngLat(\n    newCenterWorld,\n    zoomToScale(newZoom));\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\n/* eslint-enable max-statements */\n"]},"metadata":{},"sourceType":"module"}